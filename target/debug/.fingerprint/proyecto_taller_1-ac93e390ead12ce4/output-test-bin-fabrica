{"message":"cannot move a value of type dyn Command: the size of dyn Command cannot be statically determined","code":{"code":"E0161","explanation":"A value was moved whose size was not known at compile time.\n\nErroneous code example:\n\n```compile_fail,E0161\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<[isize]> = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \"hiding\" the value behind a reference:\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<&[isize]> = box array; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/fabrica.rs","byte_start":1731,"byte_end":1734,"line_start":84,"line_end":84,"column_start":9,"column_end":12,"is_primary":true,"text":[{"text":"        set.ejecutar(&mut hash_map).unwrap();","highlight_start":9,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0161]\u001b[0m\u001b[0m\u001b[1m: cannot move a value of type dyn Command: the size of dyn Command cannot be statically determined\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/fabrica.rs:84:9\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        set.ejecutar(&mut hash_map).unwrap();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\n\n"}
{"message":"cannot move a value of type dyn Command: the size of dyn Command cannot be statically determined","code":{"code":"E0161","explanation":"A value was moved whose size was not known at compile time.\n\nErroneous code example:\n\n```compile_fail,E0161\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<[isize]> = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \"hiding\" the value behind a reference:\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<&[isize]> = box array; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/fabrica.rs","byte_start":2185,"byte_end":2189,"line_start":100,"line_end":100,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"        set1.ejecutar(&mut hash_map).unwrap();","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0161]\u001b[0m\u001b[0m\u001b[1m: cannot move a value of type dyn Command: the size of dyn Command cannot be statically determined\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/fabrica.rs:100:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m100\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        set1.ejecutar(&mut hash_map).unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\n"}
{"message":"cannot move a value of type dyn Command: the size of dyn Command cannot be statically determined","code":{"code":"E0161","explanation":"A value was moved whose size was not known at compile time.\n\nErroneous code example:\n\n```compile_fail,E0161\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<[isize]> = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \"hiding\" the value behind a reference:\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<&[isize]> = box array; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/fabrica.rs","byte_start":2406,"byte_end":2410,"line_start":105,"line_end":105,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"        set2.ejecutar(&mut hash_map).unwrap();","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0161]\u001b[0m\u001b[0m\u001b[1m: cannot move a value of type dyn Command: the size of dyn Command cannot be statically determined\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/fabrica.rs:105:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        set2.ejecutar(&mut hash_map).unwrap();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0161`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0161`.\u001b[0m\n"}
